
import json
import ast
import os
import yaml

from dotenv import load_dotenv

from langchain_postgres.vectorstores import PGVector
from langchain.agents import AgentExecutor, create_tool_calling_agent,tool
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI
from langchain.tools.retriever import create_retriever_tool
from langchain_core.prompts import PromptTemplate,ChatPromptTemplate
from langchain_core.callbacks import UsageMetadataCallbackHandler

from Backend.Agent.execute import execute
from Backend.Agent import util

import requests
import json

load_dotenv()

callback = UsageMetadataCallbackHandler()

embeddings = AzureOpenAIEmbeddings(
    model="text-embedding-ada-002",
    azure_endpoint=os.getenv("TextEmb_EndPoint")
)
llm = AzureChatOpenAI(
    azure_endpoint=os.environ["GPT_EndPoint"],
    openai_api_version=os.environ["GPT_APIversion"],
    model=os.environ["GPT_model_name"],
    deployment_name=os.environ["GPT_deployment"],
    temperature=0,

)
connection = "postgresql+psycopg://langchain:langchain@localhost:6024/langchain"  # Uses psycopg3!
collection_name = "my_docs"

vector_store = PGVector(
    embeddings=embeddings,
    collection_name=collection_name,
    connection=connection,
    use_jsonb=True,
)


# --------------------------- common tools
@tool
def getFunctionCatalog(name):
    """
        Retrieves the data catalog entry for a specific type of processing functions
        name: the function name to retrieve
        :return: dict containing all information about the data product
    """
    # TODO this should be a call to the microservice
    response = requests.get("http://127.0.0.1:5200/catalog",json={"function_name":name})
    return json.loads(response.text)

@tool
def getCatalogColumns(file):
    """
        Retrieves the data catalog entry for specific data product
        file: the file name of a specific data product
        :return: dict containing all information about the data product
    """

    if 'http' in file:
        file = file.split("/")[-1]

    response = requests.get("http://127.0.0.1:5000/catalog", json={"file": file})
    return json.loads(response.text)


# --------------------------- processing agent tools

@tool(parse_docstring=True)
def matchFunction(query, catalog_dict, filter_dict):
    """
        Matches a user query to the fitting data product described in the data catalog
        Args:
            query: user query
            catalog_dict: a data catalog item retrieved with getCatalogColumns
            filter_dict: extracted attributes and their specific values based on the user query, generated by extractFilter
        Returns:
             a url of a specific dataproduct
    """

    columns = util.getProductColumns(catalog_dict['name'])

    # TODO would be really fancy if we can get to a point where stuf like relative growth per 5 year period
    # TODO also stuff  like average per substance is still difficult
    sys_prompt = """ Your task is to identifiy what kind of function a user describes and translate that into a machine readable format
                    Only use values for the column and group by attribute you can find in the column list

                    Some examples are:
                    [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
                    {{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }}

                    Possible functions and which values they require are:
                    sum: requires at least one "column" values,which the function is performed on, can have an optional list of "group_by" values
                    mean: requires at least one "column" values,which the function is performed on, can have an optional list of "group_by" values
                    filter: pre filters the data but returns all columns, requires at least on filter attribute based on the filter dict
                    getRows: returns only the specified columns,requires at least one "column" and optionaly specific values 
                """
    input_prompt = PromptTemplate.from_template("""
        User Query:{query}
        available columns:{columns}
        filter_dict: {filter_dict}
    """)
    input_prompt = input_prompt.format(query=query, columns=columns, filter_dict=filter_dict)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


@tool(parse_docstring=True)
def extractFilter(query, catalog_dict):
    """
    Creates a dict including filter atrributes and values for the getDataProduct tool
    Args:
        query: the original user query
        catalog_dict: a dict containing information abpout the data product, can be retrieved with getCatalogColumns
    Returns:
         a dict with the corresponding filters such as dict={'Country1':'Austria','Country2':'Germany','min_year':1990,'max_year':1999}
    """
    columns = util.getProductColumns(catalog_dict['name'])

    sys_prompt = """Your task is to identify a filterable attribuites in a user query and find how they can be answerd with the data columns present in the data .
                    Only return filters you can find in the data columns
                    Return all filter in a dict 
                    Example 
                    user query : "I would like to have the generall CO2 emissions data of Germany and Austria for the years 2000 to 2010"
                    response: {'Country':['Austria','Germany'],"year":{"min":2000,"max":2010} }
                    user query : "The Co2 data for Aruba where the emissions are between 0.02 and 0.03, from 1990 onward"
                    response: {'Country': 'Aruba', "value":{'min': 0.02, 'max': 0.03} "year":{'min':1990} }
                    user query : "Customer sales data of women over 38 paying by credit card"
                    response: {'gender': 'Women', 'age':{'min':38,'max':38} , 'pyament': "credit card"}
                    user query : "Customers who have not payed with creddit card"
                    response: {'gender': 'Women' , 'pyament': {'not':"credit card"}}
                    """

    input_prompt = PromptTemplate.from_template("""
            User Query:{query}
            available columns:{columns}
            """)
    input_prompt = input_prompt.format(query=query, columns=columns)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


# --------------------------- other agents

def init_processing_agent():
    sys_prompt = """ Your task is to identify and match the necerssary steps and functions to transform a data product based on a users query
                    Use the extractFilter and matchFunction tool !

                    The output should be a string containing a list of valid of python dictionaires, each dict containing one execution step and the necerssary values:
                    User query: "All females customers who paid with Credit Card and are at least 38 years old"
                    response: [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38,"max":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
                    User query: "Average of cost off all item categorys per shopping mall"
                    response: [{{"function": "mean", "values": {{"column": "price","group_by":["category","shopping_mall"]}} }}]
                    do not return a json, return only the result ith no explanantion
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [matchFunction, extractFilter, getCatalogColumns,getFunctionCatalog]

    agent = create_tool_calling_agent(llm, tools, prompt)

    return AgentExecutor(agent=agent, tools=tools, verbose=True)


def init_retrieval_agent():
    sys_prompt = """ Your task is to help identify the correct url and data product for a user based on their query
                    Only provide one url at a time together withe the name of the data product.
                    The output should be a valid json formatted as follwos:
                    {{"name":"name","url":"http://127.0.0.1:5000/exampleUrl"}}
    """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    retriever_tool = create_retriever_tool(
        vector_store.as_retriever(),
        "data_retriever",
        "Searches and returns Data files aboout diffrent statistics ",
    )

    tools = [retriever_tool, getCatalogColumns]

    agent = create_tool_calling_agent(llm, tools, prompt)

    return AgentExecutor(agent=agent, tools=tools, verbose=True)


# --------------------------- planning agent tools

@tool
def createExecutionPlan(query: str, dataProduct):
    """
    Creates an execution plan based on the input
    :param query: a query extracted from the original user input with breakDownQuery
    :param dataProduct: name of the data product ( by identifyDataProduct )
    :return: [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38,"max":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
    """
    query = query + f"The correct data products name is {dataProduct}"
    pagent = init_processing_agent()
    agent_result = pagent.invoke({"input": query}, config={"callbacks": [callback]})['output']
    agent_result = ast.literal_eval(agent_result)
    return agent_result


@tool
def identifyDataProduct(query: str):
    """
    Calls a retriever agent that identfies the most fitting data product for the input query
    :param query: a user query defining a specifc data product
    :return: {{"name":"name","url":"http://127.0.0.1:5000/exampleUrl"}}
    """
    ragent = init_retrieval_agent()
    agent_result = ragent.invoke({"input": query}, config={"callbacks": [callback]})['output']
    agent_result = json.loads(agent_result)

    return agent_result


@tool
def breakDownQuery(query: str):
    """
    Breaks down a user query into multiple steps
    :param query user query asking for an data product
    :return: list of steps
    """
    sys_prompt = """ Your task is to deconstruct a user query into multipe parts if necerssary.
                    Example
                    User query: Based on the customer data of women over 38 who have paid with credit cards I want to see the sum of all sales per category in the sales data
                    parts:["customer data of women over 38 who have paid with credit cards", "the sum of all sales per category in the sales data"]

                    User query: Average age of all customers who previously have bought toys, by gender
                    parts:["Customers who have bought toys", "Average age by gender"]

                    User query: "All females customers who paid with Credit Card and are at least 38 years old"
                    parts:["Females who paid ith credit card over 38"]
        """
    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                """)
    input_prompt = input_prompt.format(query=query)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


# --------------------------- planning agent

def init_planning_agent():
    sys_prompt = """ Your task is to create an execution plan for a user query.
                    
                    Example:
                    user:"The mall ith the most items sold"
                    output:  {{"products":[{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","transformation":[{{"function":"http://127.0.0.1:5200/sum","values":{{"group_by":"shopping_mall","column":"quantity"}} }} ,{{"function":"http://127.0.0.1:5200/max","values":{{"column":"shopping_mall"}} }}]  }}], "combination":[] }}
                    user: "All customer data of customers who have bought at least 1 book"
                    output: {{"products":[{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","transformation":[{{"function":"http://127.0.0.1:5200/filter","columns":{{"category":"books"}} }} ,{{"function":"http://127.0.0.1:5200/getRows",filter_dict:{{"values":"None","column":"customer_id"}} }}]  }} ,{{"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data_23","transformation":[]}}], "combination":[{{"column":"customer_id","type":"equals","values":["None"]}}] }}
                    
                    Do only return the result, keep to the provided schema, and do not explain it 
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [identifyDataProduct, breakDownQuery, createExecutionPlan,getFunctionCatalog]

    agent = create_tool_calling_agent(llm, tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True)


def runQuery(query):
    agent = init_planning_agent()
    agent_result = agent.invoke({'input': query}, config={"callbacks": [callback]})
    return agent_result,callback

def runQueryRemote(query):
    result,meta = runQuery(query)
    result = ast.literal_eval(result['output'])
    df = execute(result)

    return df



if __name__ == "__main__":
    user = "Based on this query generate the calls {'product': ['LULUCF_macroregions'], 'query': 'SELECT \"Macro-region\", Sector, Substance FROM LULUCF_macroregions;'}"
    user = "The year of the highest per GDP greenhouse gas emissions for Turkey"
    agent = init_planning_agent()
    agent_result = agent.invoke({'input':user},config={"callbacks": [callback]})['output']
    agent_result = ast.literal_eval(agent_result)

    #agent_result = {"execute":{"p1":({"name": "GHG_totals_by_country", "url": "http://127.0.0.1:5000/products/EDGAR_2024_GHG/GHG_totals_by_country"},[{"function":"filter","values":{"Country":"Germany"}},{"function":"getRows","values":{"columns":["2000","2001","2002","2003","2004","2005","2006","2007","2008","2009"]}}])}}

    print(execute(agent_result))
    print(callback.usage_metadata)

