import ast
import os

import pandas as pd
import yaml
import requests
import json

from dotenv import load_dotenv
from langchain_postgres.vectorstores import PGVector
from langchain.agents import AgentExecutor, create_tool_calling_agent, tool
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI
from langchain.tools.retriever import create_retriever_tool
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate
from langchain_core.callbacks import UsageMetadataCallbackHandler
from langchain_community.callbacks import get_openai_callback
from Backend import models
from Backend.Agent import execute
from Backend.RAG import vector_db,retriever
@tool
def getCatalogItem(file):
    """
        Retrieves the data catalog entry for specific data product
        file: the file name of a specific data product
        :return: dict containing all information about the data product
    """

    if 'http' in file:
        file = file.split("/")[-1]

    response = requests.get("http://127.0.0.1:5000/catalog", json={"file": file})
    return json.loads(response.text)

@tool(parse_docstring=True)
def getFunctionCatalog(func_name):
    """
    Retrieves the function catalog entry with further information
    Args:
        func_name: the name of a function
    Returns:
         a dict describing the function
    """

    response = requests.get("http://127.0.0.1:5200/catalog", json={"function_name": func_name})
    return json.loads(response.text)

@tool(parse_docstring=True)
def getCatalogColumns(file):
    """
    Retrieves the data catalog entry for specific data product
    Args:
        file: the file name of a specific data product
    Returns:
         a list of all column names in the data product
    """

    if 'http' in file:
        file = file.split("/")[-1]

    response = requests.get("http://127.0.0.1:5000/catalog/columns", json={"file": file})
    return json.loads(response.text)


@tool(parse_docstring=True)
def functionRetriever(step):
    """
    Searches and returns Data files aboout the functions accesible for the processing. Only usefull when trying to identify a function
    Args:
        step: a specific step in an execution plan, describing some kind of agreggation,transformation or filtering
    Returns:
        a text descrbing potential functions
    """
    prompt = """Your task is to find a the top 2 fitting functions that could solve problem described in the provided step.
                Provide the most fitting function and its full description. Your answer is mewant to be short and precise exclude any additional examples.
                
                Context: {context} 
                Answer:
    """
    mod_query = f"I am looking for a function that can solve the following problem for me :{step}"
    config = {"filter":{"type":{"$eq":"function"}}}
    retrieval_chain = retriever.getChain(prompt,config)
    return retrieval_chain.invoke(mod_query)


@tool(parse_docstring=True)
def productRetrieverStep(query, step):
    """
    Returns the describtion of a suitable dataproducts to answer the query. Only usefull when trying to retrieve data
    Args:
        query: a natural languge user query
        step: a specific retrieval step that is being solved, generated by the breakDownQuery tool
    Returns:
        a text descrbing potential functions
    """
    prompt = """Your task is to help find the best fitting data product. You are provided with a user query and a specific product that is searched for.
                Provide the most likely fitting data products, always provide the data products name and why it would fit this query
                
        Question: {question} 
        Context: {context} 
        Answer:
    """
    mod_query = f"I am looking for data products that can answer the query: '{query}'\n Specifically the retrieval question {step} "
    config = {"filter": {"type": {"$eq": "product"}}}

    retrieval_chain = retriever.getChain(prompt,config)
    return retrieval_chain.invoke(mod_query)

@tool(parse_docstring=True)
def productRetriever(query):
    """
    Returns the describtion of a suitable dataproducts to answer the query. Only usefull when trying to retrieve data
    Args:
        query: a natural languge user query
    Returns:
        a text descrbing potential functions
    """
    prompt = """Your task is to help find the best fitting data product. You are provided with a user query .
                Provide the most likely fitting data products, always provide the data products name and why it would fit this query
        Question: {question} 
        Context: {context} 
        Answer:
    """
    mod_query = f"I am looking for data products that can answer the query: '{query}'"
    config = {"filter": {"type": {"$eq": "product"}}}

    retrieval_chain = retriever.getChain(prompt,config)
    return retrieval_chain.invoke(mod_query)


@tool(parse_docstring=False)
def breakDownQuery(query: str):
    """
    Breaks down a user query into its multiple steps
    Args:
        query:  a natural languge query
        prod_descriptions: information about potentially fitting data products
    Returns:
        a list of steps necerssary to solve the query
    """

    # Identify fitting data collection
    mod_query = f"I am looking for data products that can answer the query: '{query}'"
    prod_descriptions = retriever.collection_rag(mod_query,config=None)

    # Retrieve corresponding data catalog
    response = requests.get("http://127.0.0.1:5000/catalog/collection", json={"file": prod_descriptions["collection_name"]})
    catalog = json.loads(response.text)


    sys_prompt = """ Your task is to explain how you would slove the provided query. For this break it down into sepereate retrieval, computation and combination steps.
                You will be provided with information for fitting data products, keep the steps short but combine them if possible.
                The word retrieve is reserved for when you need to get a data product
                Multiple filter steps for the same product should be combined into one step 
                Always do all steps necerssary for one product in a row.
                When combining data always list both names 
                
                Return the steps as a orderd list.
                Example: All customer data of customers who have bought at least 1 book
                result: ["retrieve sales data","filter for customers who have bought 1 book","retrieve customer data","combine customers from sales data and custmer data","return finished product"] 
                Example: The mall with the highest books sales
                result: ["retrieve sales data","filter for book sales","calculate book sales and group by mall","combine customers from sales data and custmer data","return finished product"] 
                
                Return a valid json with the 'plan': generated list of steps, and the reasoning as 'explanation': why these steps are needed and in which order
        """
    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                """)
    input_prompt = input_prompt.format(query=query,catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    #llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    return response["plan"]


@tool(parse_docstring=False)
def transformRetrieval(step: str, prod_description: str, columns: list[str]):
    """
    Breaks down a user query into its multiple steps
    Args:
        step:  a retrieval step in a query that is being solved
        prod_description: a data product description can be retrieved with the getCatalogItems Tool
        columns: relevant columns for the query
    Returns:
        a dict containing a function api and its parameters
    """
    sys_prompt = """ Your task is generate a retrieval step, follow the example below:
                    
                    Example:
                    step: aggregate total items sold for each mall
                    prod_description: 
                    base_api: http://127.0.0.1:5000/products/Sales_Data/sales_data_23
                    columns:
                    - invoice_no
                    - customer_id
                    - category
                    - quantity
                    - price
                    - invoice_date
                    - shopping_mall

                    {{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data_23" }} }}
                    
                    The result should be a vaild json with "function": the api to call and "filter_dict" : a dict containin the key product and the product api
                    
 """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                prod_description: {prod_description}
                columns: {columns}
                """)
    input_prompt = input_prompt.format(step=step, prod_description=prod_description, columns=columns)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=False)
def generate_function_call(step: str,function_name:str):
    """
    Generates a function call
    Args:
        step:  a step in a query that is being solved
        function_name: a describtion of the function, get it from the functionRetriever tool
    Returns:
        a dict containing a function api and its parameters
    """


    # Retrieve corresponding function catalog
    response = requests.get("http://127.0.0.1:5200/catalog", json={"function_name": function_name})
    catalog = json.loads(response.text)


    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. use the following examples as a guide:
                     Make sure that you only use 
                    Example:
                    step: aggregate total items sold for each mall
                    func_description: 
                    **Description**: This function calculates the sum of specified columns in a dataframe, optionally grouping the results by one or more columns. It requires a list of columns for which the sum should be calculated (cannot be None) and allows for grouping by a list of columns (can be None).
                    **API Endpoint**: [http://127.0.0.1:5200/sum](http://127.0.0.1:5200/sum)
                    **Filter Dictionary**:
                    - `group_by`: A list of columns in the dataframe (can be None).
                    - `columns`: A list of columns for which the sum should be calculated (cannot be None).
                    columns: ["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]
                    
                    result : {{"function":"http://127.0.0.1:5200/sum","values":{{"group_by":"shopping_mall","column":"quantity"}}
                    
                    Example:
                    step: identify the mall with the highest total items sold
                    func_description:
                    **Description**: The `max` function retrieves the maximum value for a specified list of columns in a dataframe. It requires a filter dictionary that includes the columns for which the maximum values should be retrieved.
                    **API Endpoint**: `http://127.0.0.1:5200/max`
                    **Filter Dictionary**: 
                    - `columns`: A list of columns for which the maximum should be retrieved.
                    columns: ["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]
                    
                    result : {{"function":"http://127.0.0.1:5200/max","values":{{"column":"shopping_mall"}} }}
                    
                    Example:
                    step: retrieve sales data from sales_data_23
                    func_description:
                    The most fitting function is **retrieve**. 
                    **Description**: The `retrieve` function retrieves the specified data product by taking the data product's name and a list of requested columns as arguments. It allows users to access specific data points efficiently. 
                    **Filter Dictionary**: 
                    - `{'product': 'api of the data product'}`
                    - `{'columns': 'list of columns to retrieve'}`
                    columns: ["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]
                    
                    result : {{"function":"http://127.0.0.1:5200/retrieve","values":{{"columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"],"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data_23" }} }}
        """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                func_description: {func_description}
                """)
    input_prompt = input_prompt.format(step=step,func_description=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=False)
def transformCombination(step: str,  columns_left: list[str],columns_right: list[str]):
    """
    Breaks down a user query into its multiple steps
    Args:
        step:  a step in a query that is being solved
        func_description: a describtion of the function, get it from the functionRetriever tool
        columns: a list of columns in a data product that is needed to solve step
    Returns:
        a dict containing a function api and its parameters
    """
    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. use the following examples as a guide:
                     Make sure that you only use 
                    Example:
                    step: combine customers from sales data and custmer data
                    columns_left: [customer_id]
                    columns_right: [customer_id]

                    result : "combination":[{{"column":"customer_id","type":"equals","values":["None"]}} ]

                     """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                columns_left: {columns_left}
                columns_right: {columns_right}
                """)
    input_prompt = input_prompt.format(step=step, columns_left=columns_left, columns_right=columns_right)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_LLM()

    return llm.invoke(messages)


def init_agent():
    sys_prompt = """ Your task is to create an execution plan for a user query.
                    For this use the provided tools to 
                    1. break down the query into its sub steps using the breakDownQuery tool
                    2. for each substep identfiy the necerssary function call using the functionRetriever and productRetriever tool
                    3. transfrom the output to fit the schema
                
                    Example:
                    user:"The mall ith the most items sold"
                    output:  {{"plans":[{{"function":"http://127.0.0.1:5200/retrieve","values":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}} }},{{"function":"http://127.0.0.1:5200/filter","values":{{"columns":"category","criteria":{{"category":"book"}} }} }},{{"function":"http://127.0.0.1:5200/sum","values":{{"group_by":"shopping_mall","column":"quantity"}} }},{{"function":"http://127.0.0.1:5200/sortby","values":{{"columns":"quantity","order":"descending"}} }}],"combination":[] }}
                    user: "All customer data of customers who have bought at least 1 book"
                    output: {{"plans":[{{"function":"http://127.0.0.1:5200/retrieve","values":{{"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data_23","columns":["customer_id","category"]}} }},{{"function":"http://127.0.0.1:5200/filter","values":{{"columns":{{"category":"book"}} }} }},{{"function":"http://127.0.0.1:5200/getRows","values":{{"filter_dict":{{"values":"None","column":"customer_id"}} }} }},{{"function":"http://127.0.0.1:5200/retrieve","values":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["customer_id","gender","age","payment_method"]}} }}],"combination":[{{"column":"customer_id","type":"equals","values":["None"]}} ] }}
                    Do only return the result, keep to the provided schema, and do not explain it 
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [breakDownQuery, getCatalogItem,functionRetriever,productRetrieverStep,generate_function_call,getFunctionCatalog,transformRetrieval,transformCombination]

    agent = create_tool_calling_agent(models.get_LLM(), tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True)

if __name__ == "__main__":
    #print(functionRetriever.invoke("filter sales data for the book category"))
    #The mall with the most items sold
    #print(breakDownQuery.invoke("All Customers between 30 and 50 years old"))
    # retrieve sales data from all malls
    #print(productRetriever.invoke({"query":"The mall ith the most items sold","step":"retrieve sales data from all malls"}))
    #aggregate total items sold for each mall
    #identify the mall with the highest total items sold
    #print(functionRetriever.invoke({"step":"filter sales data to include only book sales"}))
    #TODO solve combine issue --> is returned when not fitting
    #TODO filter tool keeps doing ">38"
    #TODO does not call function retriever
    #TODO rework transform step cause weird
    #TODO combine is still a problem
    #todo adjust filter in main call
    #'retrieve sales data from sales_data_23'
    #'filter sales data for book category'
    #'identify the mall with the highest total book sales'
    #{"plans":[[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["category"],"values":["books"]}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":"shopping_mall","column":"quantity"}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["quantity"],"order":"descending"}}]],"combination":[]}}

    # think of good output format for combinations bacck to products seperatly ?
    with get_openai_callback() as cb:
        agent_i = init_agent()
        #sql = "From the sales data i would like to know the total amount of money spent per category of available items, of Females over 38"
        sql = "The year of the highest per GDP greenhouse gas emissions for Turkey"
        sql = "The mall with the highest books sales"

        #sql = "All customer data of customers who have bought at least 1 book"
        sql = "What is the Simplified Chinese translation of the name of the set 'Eighth Edition'?"
        #print(breakDownQuery.invoke({"query":sql}))
        agent_result = agent_i.invoke({'input': sql})['output']
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"columns":["Text","UserId","UserDisplayName"],"product":"http://127.0.0.1:5000/products/codebase_community/comments"}},{"function":"http://127.0.0.1:5200/filter","values":{"conditions":{"Text":"thank you user93!"}}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["UserId","UserDisplayName"],"ascending":"True"}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":null,"columns":["UserId","UserDisplayName"]}}],"combination":[]}
        print(agent_result)
        agent_result = ast.literal_eval(agent_result)
        #agent_result = {"plans":[[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"conditions":{"category":"books"},"columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":"shopping_mall","column":"quantity"}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["shopping_mall","quantity"]}}]],"combination":[] }
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["customer_id","category"],"conditions":[{"column":"category","value":"book"}]}},{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data","columns":["customer_id","gender","age","payment_method"]}}],"combination":[{"column":"customer_id","type":"equals","values":["None"]}]}
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"columns":["Text","UserId","UserDisplayName"],"product":"http://127.0.0.1:5000/products/codebase_community/comments"}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["Text"],"criteria":{"Text":"thank you user93!"}}},{"function":"http://127.0.0.1:5200/min","values":{"columns":["UserId","UserDisplayName"],"rows":1}},{"function":"http://127.0.0.1:5200/max","values":{"columns":["UserId","UserDisplayName"],"rows":1}}],"combination":[]}

        print(execute.execute_new(agent_result))