import ast
import os

import pandas as pd
import yaml
import requests
import json

from dotenv import load_dotenv
from langchain_postgres.vectorstores import PGVector
from langchain.agents import AgentExecutor, create_tool_calling_agent, tool
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI
from langchain.tools.retriever import create_retriever_tool
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate
from langchain_core.callbacks import UsageMetadataCallbackHandler
from langchain_community.callbacks import get_openai_callback
from Backend import models
from Backend.Agent import execute
from Backend.RAG import vector_db,retriever


@tool(parse_docstring=True)
def functionRetriever(step):
    """
    Searches and returns Data files aboout the functions accesible for the processing. Only usefull when trying to identify a function
    Args:
        step: a specific step in an execution plan, describing some kind of agreggation,transformation or filtering
    Returns:
        a text descrbing potential functions
    """

    mod_query = f"I am looking for a function that can solve the following problem for me :{step}"
    function = retriever.function_rag(mod_query)
    return function["function_name"]


@tool(parse_docstring=True)
def productRetrieverStep(step):
    """
    Returns the describtion of a suitable dataproducts to answer the query. Only usefull when trying to retrieve data
    Args:
        step: a specific retrieval step that is being solved, generated by the breakDownQuery tool
    Returns:
        a text descrbing potential functions
    """

    mod_query = f"I am looking for data products that can answer the query: '{step}'"

    product = retriever.product_rag(mod_query)
    print(product)
    return product["name"]


@tool(parse_docstring=True)
def breakDownQuery(query):
    """
    Breaks down a user query into its multiple steps
    Args:
        query:  a natural languge query
    Returns:
        a list of steps necerssary to solve the query
    """

    # Identify fitting data collection
    mod_query = f"I am looking for data products that can answer the query: '{query}'"

    prod_descriptions = retriever.collection_rag(mod_query,config=None)
    print(prod_descriptions)

    # Retrieve corresponding data catalog
    response = requests.get("http://127.0.0.1:5000/catalog/collection", json={"file": prod_descriptions["collection_name"]})
    catalog = json.loads(response.text)


    sys_prompt = """ Your task is to explain how you would slove the provided query. For this break it down into sepereate retrieval, computation and combination steps.
                You will be provided with information for fitting data products, keep the steps short but combine them if possible.
                The word retrieve is reserved for when you need to get a data product. Keep these steps short. Retrieval instruction should only be the name of the data product
                Keep in mind that when you combine multiple filterd products they will all be filterd
                Multiple filter steps for the same product should be combined into one step. 
                Use returnResult for providing the finished product
                Always do all steps necerssary for one product in a row.
                When combining data always list both names 
                Remember that you need to combine data if multiple data products are necerssary
                
                Example: All customer data of customers who have bought at least 1 book
                result: ["retrieve sales data","filter for customers who have bought 1 book","retrieve customer data","combine customers from sales data and custmer data","return finished product"] 
                
                Return a valid json with the 'plan': generated list of steps, and the reasoning as 'explanation': why these steps are needed and in which order
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                """)
    input_prompt = input_prompt.format(query=query,catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    #llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    return response["plan"]


@tool(parse_docstring=True)
def generate_retrieve(step, product_name):
    """
    Breaks down a user query into its multiple steps
    Args:
        step:  a retrieval step in a query that is being solved
        product_name: the name of the data product
    Returns:
        a dict containing a function api and its parameters
    """

    # Retrieve corresponding data catalog

    if 'http' in product_name:
        product_name = file.split("/")[-1]

    response = requests.get("http://127.0.0.1:5000/catalog", json={"file": product_name})
    catalog = json.loads(response.text)

    sys_prompt = """ Your task is generate a retrieval step, follow the example below:
                    
                    Example:
                    step: aggregate total items sold for each mall
                    prod_description: 
                    base_api: http://127.0.0.1:5000/products/Sales_Data/sales_data_23
                    columns:
                    - invoice_no
                    - customer_id
                    - category
                    - quantity
                    - price
                    - invoice_date
                    - shopping_mall

                    Result: {{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":http://127.0.0.1:5000/products/Sales_Data/sales_data_23 }} }}
                    
                    The result should be a vaild json with "function": the api to call and "filter_dict" : a dict containin the key product and the product api       
    """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                catalog: {catalog}
                """)
    input_prompt = input_prompt.format(step=step, catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=True)
def generate_function(step,function_name,product_name):
    """
    Generates a function call
    Args:
        step:  a step in a query that is being solved
        function_name: the name of the function that can solve the step, can be found with the functionRetriever tool
        product_name: the name of the data product, or previous for processing a previous result, not an api
    Returns:
        a dict containing a function api and its parameters
    """
    if "_" in function_name:
        function_name = functionRetriever.invoke(input={"step":step})

    # Retrieve corresponding function catalog
    response = requests.get("http://127.0.0.1:5200/catalog", json={"function_name": function_name})
    function_catalog = json.loads(response.text)

    if "base_api" in function_catalog:
        if function_catalog["base_api"] == "http://127.0.0.1:5200/retrieve":
            return "skip"

    if product_name not in ["combined_data","previous"]:
        response = requests.get("http://127.0.0.1:5000/catalog", json={"file": product_name})
        data_catalog = json.loads(response.text)
    else:
        data_catalog = ""

    if "text" in data_catalog:
        if data_catalog["text"] =="No fitting collection found":
            data_catalog = ""


    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. use the following examples as a guide:
                     Make sure that you only use coloumns present in the data, and use parameters if necerssary
                     If the filter_dict is described as none dont only provide the function part
                    Example:
                    step: aggregate total items sold for groupd_by each mall
                    func_description: 
                    **Description**: This function calculates the sum of specified columns in a dataframe, optionally grouping the results by one or more columns. It requires a list of columns for which the sum should be calculated (cannot be None) and allows for grouping by a list of columns (can be None).
                    **API Endpoint**: [http://127.0.0.1:5200/sum](http://127.0.0.1:5200/sum)
                    **Filter Dictionary**:
                    - `group_by`: A list of columns in the dataframe (can be None).
                    - `columns`: A list of columns for which the sum should be calculated (cannot be None).
                    
                    data product columns:
                    [invoice_no,customer_id,category,quantity,price,invoice_date,shopping_mall]
                    
                    result : {{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}}
                    
                    The result should be a vaild json with "function": the api to call and "filter_dict" : a dict containin the key product and the product api
                    """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                func_description: {func_description}
                data product columns: {data_catalog}
                """)
    input_prompt = input_prompt.format(step=step,func_description=function_catalog,data_catalog=data_catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=True)
def generate_combination(step,first_product_name,second_product_name):
    """
    Creates a the combination step
    Args:
        step:  a step in a query that is being solved
        first_product_name: name of the data produc product that should be combined can be found with the productRetrieverStep tool
        second_product_name: name of the second product that should be combined can be found with the productRetrieverStep tool
    Returns:
        a dict containing a function api and its parameters
    """
    response = requests.get("http://127.0.0.1:5000/catalog/columns", json={"file": first_product_name})
    columns_left = json.loads(response.text)

    response = requests.get("http://127.0.0.1:5000/catalog/columns", json={"file": second_product_name})
    columns_right = json.loads(response.text)

    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. 
                    The you are give a description of the step, and the list of all columns of the first data product and the second data product
                    use the following examples as a guide:
                     
                    Example:
                    step: combine customers from sales data and customer data
                    columns_left: [invoice_no,customer_id,category,quantity,price,invoice_date,shopping_mall]
                    columns_right: [customer_id,gender,age,payment_method]

                    result : {{"function":"combination","filter_dict":{{"columns_left":"customer_id","columns_right":"customer_id","type":"equals","values":["None"]}} }}
                    
                    The result should be a vaild json with "function":"combination" and "filter_dict" containing the keys columns_left,columns_right,type and values set to the corresponding value
                     """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                columns_left: {columns_left}
                columns_right: {columns_right}
                """)
    input_prompt = input_prompt.format(step=step, columns_left=columns_left, columns_right=columns_right)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)

@tool(parse_docstring=True,return_direct=True)
def format_output(steps, function_calls):
    """
    Breaks down a user query into its multiple steps
    Args:
        function_calls:  a list the output from the generate_function_call Tool or generate_combination Tool
        steps: the list of steps necerssary to solve the problem
    Returns:
        a dict containing a function api and its parameters
    """
    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. 
                    The result should be a orderd list of function calls according to the steps 
                    
                    Example:
                    steps: ["retrieve sales data","filter for book sales","group sales by shoping mall","sort sales by quantity descending"]
                    function_calls:[{{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}} }},
                    {{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}} }},
                    {{"function":"http://127.0.0.1:5200/filter","filter_dict":{{"columns":"category","criteria":{{"category":"book"}} }} }}
                    {{"function":"http://127.0.0.1:5200/sortby","filter_dict":{{"columns":"quantity","order":"descending"}} }}]
                
                    result: [{{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}} }},{{"function":"http://127.0.0.1:5200/filter","filter_dict":{{"columns":"category","criteria":{{"category":"book"}} }} }},{{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}} }},{{"function":"http://127.0.0.1:5200/sortby","filter_dict":{{"columns":"quantity","order":"descending"}} }} ]
                    
                    the result should be a list of valid jsons with 'plans': list of function calls
                     """
    input_prompt = PromptTemplate.from_template("""
                function_calls: {function_calls}
                steps:{steps}
                """)
    input_prompt = input_prompt.format(steps=steps, function_calls=function_calls)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)

@tool(parse_docstring=False)
def reiterate_plan(steps,collection_name,query):
    """
        Breaks down a user query into its multiple steps
        Args:
            query:  a natural languge query
            steps: the first ioteration of steps
            collection_name: the name of the collection needed to solve
        Returns:
            a list of corrected steps necerssary to solve the query
        """
    response = requests.get("http://127.0.0.1:5000/catalog/collection",
                            json={"file": collection_name})
    catalog = json.loads(response.text)

    sys_prompt = """ Your task is to verify an execution plan and correct it if necerssary.
        You are given a list of steps and a dict of the available columns in all data products. 
        Keep all steps that can be solved with the provided information and correct or remove the ones that are unnecessary.
        A step is considerd unfeasible if there is no way to filter for a specific attribute given the provided columns
        
        Return a valid json with the 'plan': generated list of steps, and the reasoning as 'explanation': why these steps are needed and what needed to be change for each step
        
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                steps:{steps}
                """)
    input_prompt = input_prompt.format(query=query, catalog=catalog, steps=steps)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    # llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    print(response['explanation'])
    return response["plan"]


@tool(parse_docstring=False)
def sql_plan(collection_name, query):
    """
        Breaks down a user query into its multiple steps
        Args:
            query:  a natural languge query
            collection_name: the name of the collection needed to solve
        Returns:
            a list of corrected steps necerssary to solve the query
        """
    response = requests.get("http://127.0.0.1:5000/catalog/collection",
                            json={"file": collection_name})
    catalog = json.loads(response.text)
    print(catalog)
    sys_prompt = """ Your task is to create an sql that can solve a user query, you are provided with the user query as input as well as all data products and their corresponding columns
                the output should be a valid json with "sql": the generated sql and 'explanation': as an explanantion of the sql
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                """)
    input_prompt = input_prompt.format(query=query, catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    # llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    return response["sql"]

def init_agent():
    sys_prompt = """Your task is to create an execution plan for a user query. 
                    The first step is to break down the user query into ist substeps using the breakDownQuery tool, creating a list of tasks
                    
                    To process each of the generated steps follow this outline:
                    1. Identify which function or data product is needed using the productRetrieverStep Tool or the functionRetriever tool
                    
                    2. to produce the correct output for each step use:
                        2.a if a step contains the a variation of the word combine use the generate_combination tool,
                        2.b if a step contains the word retrieve use the generate_retrieve tools
                        2.c if none of the above are fitting or any other rask is mentioned in a step use the generate_function tool
                    3. transfrom the output to fit the schema with the format_output tool
                    
                    Directly return the result of the format_output tool !
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "The query i want to solve: {query},some additional information:{evidence}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [breakDownQuery,productRetrieverStep,functionRetriever,generate_function,generate_combination,format_output,generate_retrieve]

    agent = create_tool_calling_agent(models.get_LLM(), tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True,return_intermediate_steps=True)


if __name__ == "__main__":

    with get_openai_callback() as cb:
        agent_i = init_agent()

        sql = "Calculate the average overall rating of Pietro Marino"
        #sql = "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?"
        ev = "Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to the first 10 characters of date BETWEEN '2007-02-22' and '2016-04-21'"
        ev =""

        agent_result = agent_i.invoke({'query': sql,"evidence":ev})
        print(agent_result['output'])
        #query = f"The query i want to solve: {sql},some additional information:{ev}"
        #print(breakDownQuery.invoke(input={"query": query}))
        #print(execute.execute_new(plan))
