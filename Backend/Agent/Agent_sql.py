import ast
import os

import pandas as pd
import yaml
import requests
import json

from dotenv import load_dotenv
from langchain_postgres.vectorstores import PGVector
from langchain.agents import AgentExecutor, create_tool_calling_agent, tool
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI
from langchain.tools.retriever import create_retriever_tool
from langchain_core.prompts import PromptTemplate, ChatPromptTemplate
from langchain_core.callbacks import UsageMetadataCallbackHandler
from langchain_community.callbacks import get_openai_callback
from Backend import models
from Backend.Agent import execute
from Backend.RAG import vector_db,retriever


@tool(parse_docstring=True)
def functionRetriever(step):
    """
    Searches and returns Data files aboout the functions accesible for the processing. Only usefull when trying to identify a function
    Args:
        step: a specific step in an execution plan, describing some kind of agreggation,transformation or filtering
    Returns:
        a text descrbing potential functions
    """
    prompt = """Your task is to find a the top 2 fitting functions that could solve problem described in the provided step.
                Provide the most fitting function and its full description. Your answer is mewant to be short and precise exclude any additional examples.
                
                Context: {context} 
                Answer:
    """

    mod_query = f"I am looking for a function that can solve the following problem for me :{step}"
    config = {"filter":{"type":{"$eq":"function_NoManual"}}}
    retrieval_chain = retriever.getChain(prompt,config)
    return retrieval_chain.invoke(mod_query)


@tool(parse_docstring=True)
def productRetrieverStep(query, step):
    """
    Returns the describtion of a suitable dataproducts to answer the query. Only usefull when trying to retrieve data
    Args:
        query: a natural languge user query
        step: a specific retrieval step that is being solved, generated by the breakDownQuery tool
    Returns:
        a text descrbing potential functions
    """

    mod_query = f"I am looking for data products that can answer the query: '{query}'\n Specifically the retrieval question {step} "
    #mod_query = f"I am looking for data products that can answer the query: '{step}'"

    product = retriever.product_rag(mod_query)
    print(product)
    return product["name"]


@tool(parse_docstring=True)
def breakDownQuery(query):
    """
    Breaks down a user query into its multiple steps
    Args:
        query:  a natural languge query
    Returns:
        a list of steps necerssary to solve the query
    """

    # Identify fitting data collection
    mod_query = f"I am looking for data products that can answer the query: '{query}'"
    prod_descriptions = retriever.collection_rag(mod_query,config=None)

    # Retrieve corresponding data catalog
    response = requests.get("http://127.0.0.1:5000/catalog/collection", json={"file": prod_descriptions["collection_name"]})
    catalog = json.loads(response.text)


    sys_prompt = """ Your task is to explain how you would slove the provided query. For this break it down into sepereate retrieval, computation and combination steps.
                You will be provided with information for fitting data products, keep the steps short but combine them if possible.
                The word retrieve is reserved for when you need to get a data product.
                Multiple filter steps for the same product should be combined into one step. 
                User returnResult for providing the finished product
                Always do all steps necerssary for one product in a row.
                When combining data always list both names 
                
                Example: All customer data of customers who have bought at least 1 book
                result: ["retrieve sales data","filter for customers who have bought 1 book","retrieve customer data","combine customers from sales data and custmer data","return finished product"] 
                
                Return a valid json with the 'plan': generated list of steps, and the reasoning as 'explanation': why these steps are needed and in which order
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                """)
    input_prompt = input_prompt.format(query=query,catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    #llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    return response["plan"]


@tool(parse_docstring=True)
def generate_retrieve(step, product_name):
    """
    Breaks down a user query into its multiple steps
    Args:
        step:  a retrieval step in a query that is being solved
        product_name: the name of the data product
    Returns:
        a dict containing a function api and its parameters
    """

    # Retrieve corresponding data catalog

    if 'http' in product_name:
        product_name = file.split("/")[-1]

    response = requests.get("http://127.0.0.1:5000/catalog", json={"file": product_name})
    catalog = json.loads(response.text)

    sys_prompt = """ Your task is generate a retrieval step, follow the example below:
                    
                    Example:
                    step: aggregate total items sold for each mall
                    prod_description: 
                    base_api: http://127.0.0.1:5000/products/Sales_Data/sales_data_23
                    columns:
                    - invoice_no
                    - customer_id
                    - category
                    - quantity
                    - price
                    - invoice_date
                    - shopping_mall

                    Result: {{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":http://127.0.0.1:5000/products/Sales_Data/sales_data_23 }} }}
                    
                    The result should be a vaild json with "function": the api to call and "filter_dict" : a dict containin the key product and the product api       
    """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                catalog: {catalog}
                """)
    input_prompt = input_prompt.format(step=step, catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=True)
def generate_function_call(step,function_name,product_name):
    """
    Generates a function call
    Args:
        step:  a step in a query that is being solved
        function_name: a describtion of the function, get it from the functionRetriever tool
        product_name: the name of the data product
    Returns:
        a dict containing a function api and its parameters
    """


    # Retrieve corresponding function catalog
    response = requests.get("http://127.0.0.1:5200/catalog", json={"function_name": function_name})
    function_catalog = json.loads(response.text)
    if product_name != "combined_data":
        response = requests.get("http://127.0.0.1:5000/catalog", json={"file": product_name})
        data_catalog = json.loads(response.text)
    else:
        data_catalog = ""
    print(data_catalog)

    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. use the following examples as a guide:
                     Make sure that you only use 
                    Example:
                    step: aggregate total items sold for each mall
                    func_description: 
                    **Description**: This function calculates the sum of specified columns in a dataframe, optionally grouping the results by one or more columns. It requires a list of columns for which the sum should be calculated (cannot be None) and allows for grouping by a list of columns (can be None).
                    **API Endpoint**: [http://127.0.0.1:5200/sum](http://127.0.0.1:5200/sum)
                    **Filter Dictionary**:
                    - `group_by`: A list of columns in the dataframe (can be None).
                    - `columns`: A list of columns for which the sum should be calculated (cannot be None).
                    
                    data product columns:
                    [invoice_no,customer_id,category,quantity,price,invoice_date,shopping_mall]
                    
                    result : {{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}}
                    
                    The result should be a vaild json with "function": the api to call and "filter_dict" : a dict containin the key product and the product api
                    """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                func_description: {func_description}
                data product columns: {data_catalog}
                """)
    input_prompt = input_prompt.format(step=step,func_description=function_catalog,data_catalog=data_catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)


@tool(parse_docstring=True)
def generate_combination(step,first_product_name,second_product_name):
    """
    Creates a the combination step
    Args:
        step:  a step in a query that is being solved
        first_product_name: name of the data produc product that should be combined can be found with the productRetrieverStep tool
        second_product_name: name of the second product that should be combined can be found with the productRetrieverStep tool
    Returns:
        a dict containing a function api and its parameters
    """
    response = requests.get("http://127.0.0.1:5000/catalog/columns", json={"file": first_product_name})
    columns_left = json.loads(response.text)

    response = requests.get("http://127.0.0.1:5000/catalog/columns", json={"file": second_product_name})
    columns_right = json.loads(response.text)

    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. 
                    The you are give a description of the step, and the list of all columns of the first data product and the second data product
                    use the following examples as a guide:
                     
                    Example:
                    step: combine customers from sales data and customer data
                    columns_left: [invoice_no,customer_id,category,quantity,price,invoice_date,shopping_mall]
                    columns_right: [customer_id,gender,age,payment_method]

                    result : {{"function":"combination","filter_dict":{{"columns_left":"customer_id","columns_right":"customer_id","type":"equals","values":["None"]}} }}
                    
                    The result should be a vaild json with "function":"combination" and "filter_dict" containing the keys columns_left,columns_right,type and values set to the corresponding value
                     """
    input_prompt = PromptTemplate.from_template("""
                step:{step}
                columns_left: {columns_left}
                columns_right: {columns_right}
                """)
    input_prompt = input_prompt.format(step=step, columns_left=columns_left, columns_right=columns_right)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)

@tool(parse_docstring=True,return_direct=True)
def generate_output(steps, function_calls):
    """
    Breaks down a user query into its multiple steps
    Args:
        function_calls:  a list the output from the generate_function_call Tool or generate_combination Tool
        steps: the list of steps necerssary to solve the problem
    Returns:
        a dict containing a function api and its parameters
    """
    sys_prompt = """ Your task is to combine all previously gatherd data into a preset output. 
                    The result should be a orderd list of function calls according to the steps 
                    
                    Example:
                    steps: ["retrieve sales data","filter for book sales","group sales by shoping mall","sort sales by quantity descending"]
                    function_calls:[{{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}} }},
                    {{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}} }},
                    {{"function":"http://127.0.0.1:5200/filter","filter_dict":{{"columns":"category","criteria":{{"category":"book"}} }} }}
                    {{"function":"http://127.0.0.1:5200/sortby","filter_dict":{{"columns":"quantity","order":"descending"}} }}]
                
                    result: [{{"function":"http://127.0.0.1:5200/retrieve","filter_dict":{{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}} }},{{"function":"http://127.0.0.1:5200/filter","filter_dict":{{"columns":"category","criteria":{{"category":"book"}} }} }},{{"function":"http://127.0.0.1:5200/sum","filter_dict":{{"group_by":"shopping_mall","column":"quantity"}} }},{{"function":"http://127.0.0.1:5200/sortby","filter_dict":{{"columns":"quantity","order":"descending"}} }} ]
                    
                    the result should be a list of valid jsons with 'plans': list of function calls
                     """
    input_prompt = PromptTemplate.from_template("""
                function_calls: {function_calls}
                steps:{steps}
                """)
    input_prompt = input_prompt.format(steps=steps, function_calls=function_calls)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]

    llm = models.get_structured_LLM()

    return llm.invoke(messages)

@tool(parse_docstring=False)
def reiterate_plan(sql,query):
    """
    Breaks down a sql into multiple steps
    Args:
        query:  a natural languge query
        sql: an sql to solve the query
    Returns:
        a list of steps necerssary to solve the query
    """

    # Identify fitting data collection
    sys_prompt = """ Your task is to explain how you would slove the provided query. For this break it down into sepereate retrieval, computation and combination steps.
                You will be provided with information for fitting data products, keep the steps short but combine them if possible.
                The word retrieve is reserved for when you need to get a data product.
                Multiple filter steps for the same product should be combined into one step. 
                User returnResult for providing the finished product
                Always do all steps necerssary for one product in a row.
                When combining data always list both names 

                Example: All customer data of customers who have bought at least 1 book
                result: ["retrieve sales data","filter for customers who have bought 1 book","retrieve customer data","combine customers from sales data and custmer data","return finished product"] 

                Return a valid json with the 'plan': generated list of steps, and the reasoning as 'explanation': why these steps are needed and in which order
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                sql :{sql}
                """)
    input_prompt = input_prompt.format(query=query, catalog=sql)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    # llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    return response["plan"]


@tool(parse_docstring=False)
def sql_plan(collection_name, query):
    """
        Breaks down a user query into its multiple steps
        Args:
            query:  a natural languge query
            collection_name: the name of the collection needed to solve
        Returns:
            a list of corrected steps necerssary to solve the query
        """
    # Identify fitting data collection
    mod_query = f"I am looking for data products that can answer the query: '{query}'"
    prod_descriptions = retriever.collection_rag(mod_query, config=None)

    # Retrieve corresponding data catalog
    response = requests.get("http://127.0.0.1:5000/catalog/collection",
                            json={"file": prod_descriptions["collection_name"]})
    catalog = json.loads(response.text)

    sys_prompt = """ Your task is to create an sql that can solve a user query, you are provided with the user query as input as well as all data products and their corresponding columns
                the output should be a valid json with "sql": the generated sql and 'explanation': as an explanantion of the sql
        """

    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                product catalog :{catalog}
                """)
    input_prompt = input_prompt.format(query=query, catalog=catalog)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    # llm = models.get_LLM()
    llm = models.get_structured_LLM()
    response = llm.invoke(messages)
    print(response['explanation'])
    return response["sql"],collection_name

def init_agent():
    sys_prompt = """Your task is to create an execution plan for a user query. 
                    The first step is to break down the user query into ist substeps using the breakDownQuery tool
                    To solve each of the steps in order use the provided tools to 
                     1. break down the query into its sub steps using the breakDownQuery tool
                    2. for each substep identfiy the necerssary function call, if a step contains the a variation of the word combine use the generate_combination tool,
                    for a retrieval step use the generate_retrieve tools and for every other function use the generate_function_call tool
                    3. transfrom the output to fit the schema with the generate_output tool
                    4. directly return the result of the generate_output tool
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [breakDownQuery, functionRetriever,productRetrieverStep,generate_function_call,generate_combination,generate_output,generate_retrieve]

    agent = create_tool_calling_agent(models.get_LLM(), tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True,return_intermediate_steps=True)

if __name__ == "__main__":
    #print(functionRetriever.invoke("filter sales data for the book category"))
    #The mall with the most items sold
    #print(breakDownQuery.invoke("All Customers between 30 and 50 years old"))
    # retrieve sales data from all malls
    #print(productRetriever.invoke({"query":"The mall ith the most items sold","step":"retrieve sales data from all malls"}))
    #aggregate total items sold for each mall
    #identify the mall with the highest total items sold
    #print(functionRetriever.invoke({"step":"filter sales data to include only book sales"}))
    #TODO solve combine issue --> is returned when not fitting
    #TODO filter tool keeps doing ">38"
    #TODO does not call function retriever
    #TODO rework transform step cause weird
    #TODO combine is still a problem
    #todo adjust filter in main call
    #'retrieve sales data from sales_data_23'
    #'filter sales data for book category'
    #'identify the mall with the highest total book sales'
    #{"plans":[[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["category"],"values":["books"]}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":"shopping_mall","column":"quantity"}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["quantity"],"order":"descending"}}]],"combination":[]}}

    # think of good output format for combinations bacck to products seperatly ?
    with get_openai_callback() as cb:
        agent_i = init_agent()
        #sql = "From the sales data i would like to know the total amount of money spent per category of available items, of Females over 38"
        sql = "The year of the highest per GDP greenhouse gas emissions for Turkey"
        sql = "The mall with the highest books sales"

        #sql = "All customer data of customers who have bought at least 1 book"
        sql = "What is Copycat's race?"
        sql = "What was the average monthly consumption of customers in SME for the year 2013?"
        #"steps":['retrieve superhero data', 'filter for Copycat', 'retrieve race data', 'filter for race corresponding to Copycat', "combine Copycat's data with race data", 'return finished product'],
        print(reiterate_plan.invoke({"query":"What was the average monthly consumption of customers in SME for the year 2013?","sql":"SELECT AVG(Consumption) AS AverageMonthlyConsumption FROM yearmonth WHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'SME') AND YEAR(Date) = 2013 GROUP BY MONTH(Date)"}))
        agent_result = agent_i.invoke({'input': sql})
        #plan = agent_result['output']
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"columns":["Text","UserId","UserDisplayName"],"product":"http://127.0.0.1:5000/products/codebase_community/comments"}},{"function":"http://127.0.0.1:5200/filter","values":{"conditions":{"Text":"thank you user93!"}}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["UserId","UserDisplayName"],"ascending":"True"}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":null,"columns":["UserId","UserDisplayName"]}}],"combination":[]}
        print(agent_result['output'])
        #agent_result = ast.literal_eval(agent_result)
        #agent_result = {"plans":[[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"conditions":{"category":"books"},"columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/sum","values":{"group_by":"shopping_mall","column":"quantity"}},{"function":"http://127.0.0.1:5200/sortby","values":{"columns":["shopping_mall","quantity"]}}]],"combination":[] }
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/sales_data_23","columns":["invoice_no","customer_id","category","quantity","price","invoice_date","shopping_mall"]}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["customer_id","category"],"conditions":[{"column":"category","value":"book"}]}},{"function":"http://127.0.0.1:5200/retrieve","values":{"product":"http://127.0.0.1:5000/products/Sales_Data/customer_data","columns":["customer_id","gender","age","payment_method"]}}],"combination":[{"column":"customer_id","type":"equals","values":["None"]}]}
        #agent_result = {"plans":[{"function":"http://127.0.0.1:5200/retrieve","values":{"columns":["Text","UserId","UserDisplayName"],"product":"http://127.0.0.1:5000/products/codebase_community/comments"}},{"function":"http://127.0.0.1:5200/filter","values":{"columns":["Text"],"criteria":{"Text":"thank you user93!"}}},{"function":"http://127.0.0.1:5200/min","values":{"columns":["UserId","UserDisplayName"],"rows":1}},{"function":"http://127.0.0.1:5200/max","values":{"columns":["UserId","UserDisplayName"],"rows":1}}],"combination":[]}


        #print(execute.execute_new(plan))
