
import util
import json
import ast
import os
from transformations import aggregation
from transformations import filter

from langchain_postgres.vectorstores import PGVector

from langchain_core.prompts import PromptTemplate
from langchain.agents import AgentExecutor, create_tool_calling_agent
from langchain_core.prompts import ChatPromptTemplate
from dotenv import load_dotenv
from langchain_openai import AzureOpenAIEmbeddings, AzureChatOpenAI
from langchain.agents import tool
import yaml
from typing import List, Optional


from langchain_core.tools import StructuredTool

from langchain.tools.retriever import create_retriever_tool

from langchain_core.callbacks import UsageMetadataCallbackHandler
import langchain_core

load_dotenv()

callback = UsageMetadataCallbackHandler()

embeddings = AzureOpenAIEmbeddings(
    model="text-embedding-ada-002",
    azure_endpoint=os.getenv("TextEmb_EndPoint")
)
llm = AzureChatOpenAI(
    azure_endpoint=os.environ["GPT_EndPoint"],
    openai_api_version=os.environ["GPT_APIversion"],
    model=os.environ["GPT_model_name"],
    deployment_name=os.environ["GPT_deployment"],
    temperature=0,

)
connection = "postgresql+psycopg://langchain:langchain@localhost:6024/langchain"  # Uses psycopg3!
collection_name = "my_docs"

vector_store = PGVector(
    embeddings=embeddings,
    collection_name=collection_name,
    connection=connection,
    use_jsonb=True,
)


# --------------------------- common tools

@tool
def getCatalogItem(file):
    """
        Retrieves the data catalog entry for specific data product
        file: the file name of a specific data product
        :return: dict containing all information about the data product
    """
    # TODO this should be a call to the microservice
    try:
        with open("../dataCatalog/configs/catalog.yml") as stream:
            catalog = yaml.safe_load(stream)
    except FileNotFoundError:
        return "could not find the main catalog"

    for collection in catalog:
        if file in collection['products']:
            try:
                with open("../dataCatalog/configs/" + collection['name'] + ".yml") as stream:
                    collection_dict = yaml.safe_load(stream)
                    for product in collection_dict['products']:
                        if product['name'] == file:
                            return product

            except FileNotFoundError:
                return "could not find the specific collection catalog"


# --------------------------- processing agent tools

@tool(parse_docstring=True)
def matchFunction(query, catalog_dict, filter_dict):
    """
        Matches a user query to the fitting data product described in the data catalog
        Args:
            query: user query
            catalog_dict: a data catalog item retrieved with getCatalogItem
            filter_dict: extracted attributes and their specific values based on the user query, generated by extractFilter
        Returns:
             a url of a specific dataproduct
    """

    columns = util.getProductColumns(catalog_dict['name'])

    # TODO would be really fancy if we can get to a point where stuf like relative growth per 5 year period
    # TODO also stuff  like average per substance is still difficult
    sys_prompt = """ Your task is to identifiy what kind of function a user describes and translate that into a machine readable format
                    Only use values for the column and group by attribute you can find in the column list

                    Some examples are:
                    [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
                    {{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }}

                    Possible functions and which values they require are:
                    sum: requires at least one "column" values,which the function is performed on, can have an optional list of "group_by" values
                    mean: requires at least one "column" values,which the function is performed on, can have an optional list of "group_by" values
                    filter: pre filters the data but returns all columns, requires at least on filter attribute based on the filter dict
                    getRows: returns only the specified columns,requires at least one "column" and optionaly specific values 
                """
    input_prompt = PromptTemplate.from_template("""
        User Query:{query}
        available columns:{columns}
        filter_dict: {filter_dict}
    """)
    input_prompt = input_prompt.format(query=query, columns=columns, filter_dict=filter_dict)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


@tool(parse_docstring=True)
def extractFilter(query, catalog_dict):
    """
    Creates a dict including filter atrributes and values for the getDataProduct tool
    Args:
        query: the original user query
        catalog_dict: a dict containing information abpout the data product, can be retrieved with getCatalogItem
    Returns:
         a dict with the corresponding filters such as dict={'Country1':'Austria','Country2':'Germany','min_year':1990,'max_year':1999}
    """
    columns = util.getProductColumns(catalog_dict['name'])

    sys_prompt = """Your task is to identify a filterable attribuites in a user query and find how they can be answerd with the data columns present in the data .
                    Only return filters you can find in the data columns
                    Return all filter in a dict 
                    Example 
                    user query : "I would like to have the generall CO2 emissions data of Germany and Austria for the years 2000 to 2010"
                    response: {'Country':['Austria','Germany'],"year":{"min":2000,"max":2010} }
                    user query : "The Co2 data for Aruba where the emissions are between 0.02 and 0.03, from 1990 onward"
                    response: {'Country': 'Aruba', "value":{'min': 0.02, 'max': 0.03} "year":{'min':1990} }
                    user query : "Customer sales data of women over 38 paying by credit card"
                    response: {'gender': 'Women', 'age':{'min':38,'max':38} , 'pyament': "credit card"}
                    user query : "Customers who have not payed with creddit card"
                    response: {'gender': 'Women' , 'pyament': {'not':"credit card"}}
                    """

    input_prompt = PromptTemplate.from_template("""
            User Query:{query}
            available columns:{columns}
            """)
    input_prompt = input_prompt.format(query=query, columns=columns)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


# --------------------------- other agents

def init_processing_agent():
    sys_prompt = """ Your task is to identify and match the necerssary steps and functions to transform a data product based on a users query
                    Use the extractFilter and matchFunction tool !

                    The output should be a string containing a list of valid of python dictionaires, each dict containing one execution step and the necerssary values:
                    User query: "All females customers who paid with Credit Card and are at least 38 years old"
                    response: [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38,"max":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
                    User query: "Average of cost off all item categorys per shopping mall"
                    response: [{{"function": "mean", "values": {{"column": "price","group_by":["category","shopping_mall"]}} }}]
                    do not return a json, return only the result ith no explanantion
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [matchFunction, extractFilter, getCatalogItem]

    agent = create_tool_calling_agent(llm, tools, prompt)

    return AgentExecutor(agent=agent, tools=tools, verbose=True)


def init_retrieval_agent():
    sys_prompt = """ Your task is to help identify the correct url and data product for a user based on their query
                    Only provide one url at a time together withe the name of the data product.
                    The output should be a valid json formatted as follwos:
                    {{"name":"name","url":"http://127.0.0.1:5000/exampleUrl"}}
    """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    retriever_tool = create_retriever_tool(
        vector_store.as_retriever(),
        "data_retriever",
        "Searches and returns Data files aboout diffrent statistics ",
    )

    tools = [retriever_tool, getCatalogItem]

    agent = create_tool_calling_agent(llm, tools, prompt)

    return AgentExecutor(agent=agent, tools=tools, verbose=True)


# --------------------------- planning agent tools

@tool
def createExecutionPlan(query: str, dataProduct):
    """
    Creates an execution plan based on the input
    :param query: a query extracted from the original user input with breakDownQuery
    :param dataProduct: name of the data product ( by identifyDataProduct )
    :return: [{{"function":"filter","values":{{"gender":"Female","age":{{"min":38,"max":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}]
    """
    query = query + f"The correct data products name is {dataProduct}"
    pagent = init_processing_agent()
    agent_result = pagent.invoke({"input": query}, config={"callbacks": [callback]})['output']
    agent_result = ast.literal_eval(agent_result)
    return agent_result


@tool
def identifyDataProduct(query: str):
    """
    Calls a retriever agent that identfies the most fitting data product for the input query
    :param query: a user query defining a specifc data product
    :return: {{"name":"name","url":"http://127.0.0.1:5000/exampleUrl"}}
    """
    ragent = init_retrieval_agent()
    agent_result = ragent.invoke({"input": query}, config={"callbacks": [callback]})['output']
    agent_result = json.loads(agent_result)

    return agent_result


@tool
def breakDownQuery(query: str):
    """
    Breaks down a user query into multiple steps
    :param query user query asking for an data product
    :return: list of steps
    """
    sys_prompt = """ Your task is to deconstruct a user query into multipe parts if necerssary.
                    Example
                    User query: Based on the customer data of women over 38 who have paid with credit cards I want to see the sum of all sales per category in the sales data
                    parts:["customer data of women over 38 who have paid with credit cards", "the sum of all sales per category in the sales data"]

                    User query: Average age of all customers who previously have bought toys, by gender
                    parts:["Customers who have bought toys", "Average age by gender"]

                    User query: "All females customers who paid with Credit Card and are at least 38 years old"
                    parts:["Females who paid ith credit card over 38"]


        """
    input_prompt = PromptTemplate.from_template("""
                User Query:{query}
                """)
    input_prompt = input_prompt.format(query=query)
    messages = [
        ("system", sys_prompt),
        ("human", input_prompt),
    ]
    return llm.invoke(messages, config={"callbacks": [callback]})


# --------------------------- planning agent

def init_planning_agent():
    sys_prompt = """ Your task is to create an execution plan for a user query.
                    If more than one data product is needed use the combine structure otherwise use execute.

                    Examples for the result are keep to the provided schema:
                    user query: "All females customers who paid with Credit Card and are at least 38 years old"
                    result: {{"execute":{{"p1":({{"name": "sales_data_23", "url": "http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}},[{{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }} }},{{"function":"getRows","values":{{"customer_id":"None"}} }}])}} }}
                    user query: "Total cost per category bought by women over 38 who paid with credit card"
                    result: {{"combine":{{"p1":({{"name": "sales_data_23", "url": "http://127.0.0.1:5000/products/Sales_Data/sales_data_23"}},[{{"function":"sum","values":{{"group_by":"category","column":"price"}} }} ]),{{"p2":({{"name": "customer_data_23", "url": "http://127.0.0.1:5000/products/Sales_Data/customer_data_23"}},[{{"function":"filter","values":{{"gender":"Female","age":{{"min":38}} }} }} , {{"function":"getRows","values":{{"customer_id":"None"}} }}] )}},"column":"customer_id","type":"select","values":["None"]}}

                    Do only return the result and do not explain it 
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", sys_prompt),
            ("human", "{input}"),
            ("placeholder", "{agent_scratchpad}"),
        ]
    )

    tools = [identifyDataProduct, breakDownQuery, createExecutionPlan]

    agent = create_tool_calling_agent(llm, tools, prompt)
    return AgentExecutor(agent=agent, tools=tools, verbose=True)


def runQuery(query):
    agent = init_planning_agent()
    agent_result = agent.invoke({'input': query}, config={"callbacks": [callback]})
    return agent_result,callback


if __name__ == "__main__":
    user = "From the sales data i would like to know the total amount of money spent per category of available items, of Females over 38"
    agent = init_planning_agent()
    agent_result = agent.invoke({'input':user},config={"callbacks": [callback]})['output']
    print(callback.usage_metadata)

